package SychronizedKeywordPractice;


/**
 * The class serves as the runner for all
 * the tests regarding syncrhonization and
 * java multithreading.
 * <br><br>
 * Only for this package. The class will
 * have access to other classes and their methods
 * in order to use them in test scenarios
 * inside of methods in this class.
 *
 *
 * */
public class MainMethodRunner {
    protected static SychronizedExampleOne testObject = new SychronizedExampleOne();

    /**
     * Not sure what to do with this empty constructor,
     * automatically generated by the IDE.
     * */
    public MainMethodRunner() {
    }

    /**
     * The purpose is to call different methods which contain the
     * code that will test out the behavior of threads.
     *<br><br>
     * Doing so would remove the implementation of the test
     * away from the main method to the other method which
     * is dedicated to hold the implementation details of the
     * test.
     * <br><br>
     * The only code inside the main method are function
     * calls to the dedicated methods with the test.
     * */
    protected static void main(String[] args) {

        exampleFromGuide();
//        exampleTwoFromGuide();
    }


    /**
     * I do not know what I am doing here.
     *<br>
     * I just wanted to test out the behavior of two threads
     * using the same object and mutating the same field.
     *<br>
     * well, i did learn that when will threads be executed
     * is not up to my control but for the Operating System
     * to decide.
     *<br>
     * */
    protected void tryingOutHowSynchronizationWorksWithNoIdea() {

//        my mistake here, makes for poor readability. Too much extraction.
//        ActionToRun ActionObj = new ActionToRun();

        Runnable actionToRun = () -> {

            String threadDetails = "from Thread # " + Thread.currentThread().getName();
            SychronizedExampleOne refToTestObject = MainMethodRunner.testObject;

            System.out.println(
                    threadDetails + " : " + MainMethodRunner.testObject.getTestObject()
            );

            String changeFromThreadTwo = "This is from thread two.";
            refToTestObject.setTestObjectWithSychronizedBlock(changeFromThreadTwo);

            System.out.println(threadDetails + refToTestObject.getTestObject());
        };

        Thread testThreadOne = new Thread( actionToRun , " 1");
        Thread testThreadTwo = new Thread( actionToRun , "2");


        testThreadOne.start();
//
//        try {
//
//            testThreadOne.join();
//        } catch (InterruptedException e) {
//
//            throw new RuntimeException(e);
//        }

        testThreadTwo.start();
    }



    /**
     * I want to test out how a variable would be read, there exist
     * a separate thread making changes to the variable, while
     * there is a separate thread reading the variable then displaying
     * the data to a console.
     * <br><br>
     * The getter and setter functions are synchronized but the
     * object to mutate and read is of a normal private variable
     * belonging to the instance of the class.
     * <br><br>
     * The thread will iterate over a given period of times, duing
     * each iteration the threads would mutate the variable while
     * the other thread would read and print the value of the variable.
     * <br><br>
     * This function serves as a container for the implementation of
     * the test and as a starter for the threads responsible for
     * mutation and read-to-display process.
     * */
    protected static void exampleFromGuide() {

        SychronizedExampleOne testObjectToMutate = new SychronizedExampleOne();
        int iterationLimit = 1000;

        Thread testThreadOne = new Thread(
            () -> {
                for (int iterationCount = 0; iterationCount < iterationLimit; iterationCount++) {

                    testObjectToMutate.setTestObjectWithSychronizedBlock("" + iterationCount);

                }
            }
        );


        Thread testThreadTwo = new Thread(
            () -> {
                for (int iterationCount = 0; iterationCount < iterationLimit; iterationCount++) {

                    System.out.println(testObjectToMutate.getTestObject());

                }
            }
        );

        testThreadOne.start();
        testThreadTwo.start();
    }



    /**
     *
     * This method aims to test out what would happen to a
     * static variable of a class if it was mutated by two
     * different threads.
     * <br><br>
     * I tried out joining the threads, only starting the
     * other thread once the first thread has stopped, but
     * then again it behaved similarly to a sequentially structured
     * program. Wherein the only one instruction at a time would be
     * performed.
     * <br>
     * So I removed the joining of the threads, turned the portion
     * into a comment for future purposes.
     * <br><br>
     * The order of execution
     * of the threads is not determined and up to the discretion
     * of the Operating System.
     * <br><br>
     * The thread will have access to a class and it's static
     * methods which are responsible for mutating the static
     * variable.
     * <br><br>
     * The variable won't be mutated in this method
     * because I want this method to have only the implementation
     * of the test and nothing else, as much as possible,
     * other types of action should be located in
     * other classes or objects.
     *<br>
     * */
    protected static void exampleTwoFromGuide() {

//        SychronizedExampleOne testObjectToMutate = new SychronizedExampleOne();
        int iterationLimit = 10;

        Thread testThreadOne = new Thread(
            () -> {
                for (int iterationCount = 0; iterationCount < iterationLimit; iterationCount++) {

                    StaticSynchronizedExampleOne.incrementTestNumber();
                }
            }
        );


        Thread testThreadTwo = new Thread(
            () -> {
                for (int iterationCount = 0; iterationCount < iterationLimit; iterationCount++) {

                    StaticSynchronizedExampleOne.incrementTestNumber();
                }
            }
        );


        testThreadOne.start();
        testThreadTwo.start();

        try {

            Thread test = new Thread(
                () -> {
                    System.out.println("\n\n\n" + StaticSynchronizedExampleOne.testNumber + " : number");
                }
            );

            test.start();
//            test.join();

        }
//        catch ( InterruptedException e) {
//
//            e.printStackTrace();
//            throw new RuntimeException(e);
//        }
        catch (Exception e) {

            e.printStackTrace();
        }

    }
}